=== modified file 'Makefile.am'
--- Makefile.am	2007-10-04 23:12:37 +0000
+++ Makefile.am	2010-03-30 04:39:13 +0000
@@ -1,3 +1,2 @@
-SUBDIRS=src docs sample
+SUBDIRS=src gnome-keyring-sharp-glue docs sample
 EXTRA_DIST=Gnome.Keyring.snk
-

=== added directory 'Tests'
=== added file 'Tests/TestRing.cs'
--- Tests/TestRing.cs	1970-01-01 00:00:00 +0000
+++ Tests/TestRing.cs	2010-03-30 03:00:47 +0000
@@ -0,0 +1,415 @@
+// 
+// TestRing.cs
+//  
+// Author:
+//       Christopher James Halse Rogers <<christopher.halse.rogers@canonical.com>>
+// 
+// Copyright (c) 2010 Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+
+using System;
+using System.Collections;
+using NUnit.Framework;
+using NUnit.Framework.Constraints;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Gnome.Keyring
+{
+	public static class TestHelpers
+	{
+		public static void NotContains<T> (T toFind, ICollection<T> collection)
+		{
+			Assert.That (collection, new NotConstraint (new ContainsConstraint (toFind)));
+		}
+	}
+	
+	[TestFixture()]
+	public class TestRing
+	{
+		[SetUp()]
+		public void SetUp ()
+		{
+			try {
+				Ring.CreateKeyring ("keyring1", "password");
+			} catch (KeyringException e) {
+				if (e.ResultCode != ResultCode.AlreadyExists) {
+					throw;
+				}
+			}
+			Ring.SetDefaultKeyring ("keyring1");
+		}
+		
+		[TearDown()]
+		public void TearDown ()
+		{
+			try {
+				Ring.DeleteKeyring ("keyring1");
+				Ring.SetDefaultKeyring ("login");
+			} catch {
+				// I don't care.
+			}
+			GC.Collect ();
+		}
+		
+		[Test()]
+		public void GetDefaultKeyringNameReturnsLogin ()
+		{
+			Assert.AreEqual ("keyring1", Ring.GetDefaultKeyring ());
+		}
+		
+		[Test()]
+		public void GetKeyringsListsAllKeyrings ()
+		{
+			Assert.Contains ("keyring1", Ring.GetKeyrings ());
+		}
+		
+		[Test()]
+		public void KeyringIsAvailable ()
+		{
+			Assert.IsTrue (Ring.Available);
+		}
+		
+		[Test()]
+		public void SetDefaultKeyringUpdatesGetDefaultKeyring ()
+		{
+			string prevDefault = Ring.GetDefaultKeyring ();
+			Ring.CreateKeyring ("test1", "password");
+			try {
+				Ring.SetDefaultKeyring ("test1");
+				Assert.AreEqual ("test1", Ring.GetDefaultKeyring ());
+			} finally {
+				Ring.DeleteKeyring ("test1");
+				Ring.SetDefaultKeyring (prevDefault);
+			}
+		}
+		
+		[Test()]
+		[ExpectedException (ExpectedMessage = "No such keyring", ExceptionType = typeof (KeyringException))]
+		public void SetDefaultKeyringWithInvalidKeyringRaisesException ()
+		{
+			Ring.SetDefaultKeyring ("Keyring That Doesn't Exist");
+		}
+		
+		[Test()]
+		public void CreatedKeyringAppearsInKeyringList ()
+		{
+			Ring.ApplicationName = "Tests";
+			string keyringName = "atestkeyring";
+			Ring.CreateKeyring (keyringName, "password");
+			Assert.Contains (keyringName, Ring.GetKeyrings ());
+			Ring.DeleteKeyring (keyringName);
+		}
+		
+		[Test()]
+		[ExpectedException (ExpectedMessage = "Item already exists", ExceptionType = typeof (KeyringException))]
+		public void CreatingTheSameKeyringTwiceRaisesException ()
+		{
+			string keyringName = "anothertestkeyring";
+			Ring.CreateKeyring (keyringName, "password");
+			try {
+				Ring.CreateKeyring (keyringName, "password");
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void RemovingKeyringRemovesItFromKeyringList ()
+		{
+			string keyringName = "akeyring";
+			Ring.CreateKeyring (keyringName, "password");
+			Assert.Contains (keyringName, Ring.GetKeyrings ());
+			Ring.DeleteKeyring (keyringName);
+			TestHelpers.NotContains (keyringName, Ring.GetKeyrings ());
+		}
+		
+		[Test()]
+		public void GetKeyringInfoGetsCorrectName ()
+		{
+			string keyringName = "login";
+			KeyringInfo info = Ring.GetKeyringInfo (keyringName);
+			Assert.AreEqual (keyringName, info.Name);
+		}
+		
+		[Test()]
+		[Ignore ("Setting keyring properties is broken in libgnome-keyring.  Apparently no one uses this.")]
+		public void SetKeyringInfoUpdatesLockTimeout ()
+		{
+			string keyringName = "testkeyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				KeyringInfo info = Ring.GetKeyringInfo (keyringName);
+				info.LockTimeoutSeconds++;
+				Assert.AreNotEqual (info.LockTimeoutSeconds, Ring.GetKeyringInfo (keyringName).LockTimeoutSeconds);
+				
+				Ring.Unlock (keyringName, null);
+				Ring.SetKeyringInfo (keyringName, info);
+				Assert.AreEqual (info.LockTimeoutSeconds, Ring.GetKeyringInfo (keyringName).LockTimeoutSeconds);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		[Ignore ("Setting keyring properties is broken in libgnome-keyring.  Apparently no one uses this.")]
+		public void SetKeyringLockOnIdleUpdatesInfo ()
+		{
+			string keyringName = "theamazingtestkeyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				KeyringInfo info = Ring.GetKeyringInfo (keyringName);
+				info.LockOnIdle = !info.LockOnIdle;
+				Assert.AreNotEqual (info.LockOnIdle, Ring.GetKeyringInfo (keyringName).LockOnIdle);
+				
+				Ring.SetKeyringInfo (keyringName, info);
+				Assert.AreEqual (info.LockOnIdle, Ring.GetKeyringInfo (keyringName).LockOnIdle);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void TestIdListForLoginKeyringIsNonEmpty ()
+		{
+			Assert.IsNotEmpty (Ring.ListItemIDs ("login"));
+		}
+		
+		[Test()]
+		public void TestIdListContainsSaneIds ()
+		{
+			foreach (int i in Ring.ListItemIDs ("login")) {
+				Assert.GreaterOrEqual (i, 0);
+			}
+			CollectionAssert.AllItemsAreUnique (Ring.ListItemIDs ("login"));
+		}
+		
+		[Test()]
+		public void CreatedItemIdExistsInIdList ()
+		{
+			string keyringName = "testifu";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			Hashtable attributes = new Hashtable ();
+			attributes["name"] = "woot";
+			attributes["banana"] = "some other value";
+			attributes["eggplant"] = "aubergine";
+			attributes["apple"] = 25;
+			
+			try {
+				int id = Ring.CreateItem (keyringName, ItemType.Note, "Random note", attributes, "reallysecret", false);
+				CollectionAssert.Contains (Ring.ListItemIDs (keyringName), id);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		/*
+		 * It seems that there's no way to stop gnome-keyring-daemon from prompting the user to unlock.
+		 * So we won't get an AccessDenied exception here; we'll block until the user has dealt with the unlock dialog.
+		 */
+		[Test()]
+		[Ignore ("Requires user interaction")]
+		public void AccessingALockedKeyringPromptsToUnlock ()
+		{
+			string keyringName = "akeyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				Ring.Lock (keyringName);
+				Ring.CreateItem (keyringName, ItemType.Note, "Random note", new Hashtable (), "reallysecret", false);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void DeletingItemRemovesItFromIdList ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				int id = Ring.CreateItem (keyringName, ItemType.Note, "test data", new Hashtable (), "secret", false);
+				CollectionAssert.Contains (Ring.ListItemIDs (keyringName), id);
+				Ring.DeleteItem (keyringName, id);
+				CollectionAssert.DoesNotContain (Ring.ListItemIDs (keyringName), id);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void DataOfAddedItemPersists ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				int id = Ring.CreateItem (keyringName, ItemType.Note, "test data", new Hashtable (), "secret", false);
+				
+				ItemData item = Ring.GetItemInfo (keyringName, id);
+				Assert.AreEqual ("test data", (string)item.Attributes["name"]);
+				Assert.AreEqual ("secret", item.Secret);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void SetItemDataPersists ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				int id = Ring.CreateItem (keyringName, ItemType.Note, "test", new Hashtable (), "secret", false);
+				
+				Ring.SetItemInfo (keyringName, id, ItemType.GenericSecret, "newdisplayname", "newsecret");
+				ItemData item = Ring.GetItemInfo (keyringName, id);
+				Assert.AreEqual ("newdisplayname", (string)item.Attributes["name"]);
+				Assert.AreEqual ("newsecret", item.Secret);
+				Assert.AreEqual (ItemType.GenericSecret, item.Type);
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void GetItemAttributesReturnsCreatedValues ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				Hashtable attributes = new Hashtable ();
+				attributes["stringAttr"] = "astring";
+				attributes["uintAttr"] = 42;
+				int id = Ring.CreateItem (keyringName, ItemType.Note, "test", attributes, "secret", false);
+				
+				CollectionAssert.IsSubsetOf (attributes, Ring.GetItemAttributes (keyringName, id));
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void SetItemAttributesPersists ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				int id = Ring.CreateItem (keyringName, ItemType.Note, "test", new Hashtable (), "secret", false);
+
+				Hashtable attributes = new Hashtable ();
+				attributes["stringAttr"] = "astring";
+				attributes["meaning"] = 42;
+				attributes["UTF8"] = "♪ “The sun is a mass of incandescent gas” ♫";
+				
+				Ring.SetItemAttributes (keyringName, id, attributes);
+				
+				CollectionAssert.IsSubsetOf (attributes, Ring.GetItemAttributes (keyringName, id));
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void CreatedNetworkPasswordSetsAppropriateData ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			
+			try {
+				Hashtable data = new Hashtable ();
+				data["user"] = "raof";
+				data["domain"] = "divination";
+				data["server"] = "jeeves";
+				data["object"] = "subject";
+				data["protocol"] = "droid";
+				data["authtype"] = "smtp";
+				data["port"] = 42;
+				
+				//Password is stored in the secret.
+				int id = Ring.CreateOrModifyNetworkPassword (keyringName, (string)data["user"], (string)data["domain"], (string)data["server"],
+					(string)data["object"], (string)data["protocol"], (string)data["authtype"], (int)data["port"], "password");
+				
+				CollectionAssert.IsSubsetOf (data, Ring.GetItemAttributes (keyringName, id));
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void FindNetworkPasswordByDomainFindsAppropriateIDs ()
+		{
+			string keyringName = "keyring";
+			Ring.CreateKeyring (keyringName, "password");
+			List<int> ids = new List<int> ();
+			
+			try {
+				ids.Add (Ring.CreateOrModifyNetworkPassword (keyringName, "user", "domain", "server", "object", "protocol", "authtype", 42, "password"));
+				Ring.CreateOrModifyNetworkPassword (keyringName, "user2", "d3omain", "4server", "o5bject", "proto6col", "3authtype", 49, "password");
+				Ring.CreateItem (keyringName, ItemType.Note, "I'm not a network password", new Hashtable (), "secret", false);
+				ids.Add (Ring.CreateOrModifyNetworkPassword (keyringName, "u3ser", "domain", "server", "object", "protocol", "authtype", 42, "password"));
+				ids.Add (Ring.CreateOrModifyNetworkPassword (keyringName, "use4r", "domain", "server", "object", "protocol", "authtype", 42, "password"));
+
+				CollectionAssert.AreEquivalent (ids, Ring.FindNetworkPassword (null, "domain", null, null, null, null, 0).
+					Where ((NetItemData data) => data.Keyring == keyringName).
+					Select ((NetItemData data) => data.ItemID).ToList ());
+			} finally {
+				Ring.DeleteKeyring (keyringName);
+			}
+		}
+		
+		[Test()]
+		public void FindItemByAttributeOnlyFindsMatchingIDs ()
+		{
+			string keyringName = "keyring1";
+			
+			List<int> correct_ids = new List<int> ();
+			List<int> incorrect_ids = new List<int> ();
+			
+			Hashtable correctAttr = new Hashtable ();
+			correctAttr["banana"] = "a fruit";
+			Hashtable incorrectAttr = new Hashtable ();
+			incorrectAttr["banana"] = "a fish";
+			
+			correct_ids.Add (Ring.CreateItem (keyringName, ItemType.Note, "a note", correctAttr, "secret", false));
+			incorrect_ids.Add (Ring.CreateItem (keyringName, ItemType.GenericSecret, "not a note", incorrectAttr, "secret", false));
+			correct_ids.Add (Ring.CreateItem (keyringName, ItemType.Note, "another note", correctAttr, "notsecret", false));
+			correct_ids.Add (Ring.CreateItem (keyringName, ItemType.Note, "a third note", correctAttr, "reallysecret", false));
+			incorrect_ids.Add (Ring.CreateOrModifyNetworkPassword (keyringName, "use4r", "domain", "server", "object", "protocol", "authtype", 42, "password"));
+
+			CollectionAssert.IsSubsetOf (Ring.Find (ItemType.Note, correctAttr).
+				Where ((data) => data.Keyring == keyringName).
+				Select ((data) => data.ItemID).ToList (), correct_ids);
+			foreach (var id in incorrect_ids) {
+				CollectionAssert.DoesNotContain (Ring.Find (ItemType.Note, correctAttr).
+					Where ((data) => data.Keyring == keyringName).
+					Select ((data) => data.ItemID), id);
+			}
+		}
+	}
+}

=== modified file 'autogen.sh'
--- autogen.sh	2006-08-01 19:08:46 +0000
+++ autogen.sh	2010-03-30 05:11:57 +0000
@@ -1,4 +1,2 @@
-aclocal
-automake -a
-autoconf
+autoreconf -v -i -s
 ./configure $*

=== modified file 'configure.ac'
--- configure.ac	2009-05-07 15:32:19 +0000
+++ configure.ac	2010-03-30 04:43:32 +0000
@@ -3,6 +3,9 @@
 AC_INIT(src/Gnome.Keyring/Ring.cs)
 AC_CANONICAL_SYSTEM
 
+AC_PROG_CC
+AC_PROG_LIBTOOL
+
 API_VERSION=1.0
 VERSION=$API_VERSION.1
 
@@ -47,27 +50,14 @@
 GACUTIL_FLAGS='/gacdir $(DESTDIR)$(prefix)'
 AC_SUBST(GACUTIL_FLAGS)
 
-#
-# Use D-Bus as a fallback to get the keyring socket address
-#
-AC_ARG_ENABLE(dbus, 
-	      [AC_HELP_STRING([--enable-dbus],[compile with D-Bus support default: yes])],
-	      ENABLE_DBUS="$enableval")
-AM_CONDITIONAL(ENABLE_DBUS, test "x$ENABLE_DBUS" != "xno")
-
-CSFLAGS=
-DBUS_LIBS=
-if test "x$ENABLE_DBUS" != "xno" ; then
-	PKG_CHECK_MODULES(DBUS, ndesk-dbus-1.0 >= 0.4, HAVE_DBUS="yes", HAVE_DBUS="no")
-
-	if test "x$HAVE_DBUS" = "xno"; then
-	  AC_MSG_ERROR($DBUS_PKG_ERRORS: consider passing --enable-dbus=no to configure)
-	fi
-
-	CSFLAGS=" -d:WITH_DBUS "
-fi
+
+PKG_CHECK_MODULES(GLIB_SHARP, [glib-sharp-2.0])
+PKG_CHECK_MODULES(GNOME_KEYRING, [gnome-keyring-1])
+
 AC_SUBST(CSFLAGS)
-AC_SUBST(DBUS_LIBS)
+AC_SUBST(GLIB_SHARP_LIBS)
+AC_SUBST(GNOME_KEYRING_CFLAGS)
+AC_SUBST(GNOME_KEYRING_LIBS)
 
 AC_ARG_ENABLE(monodoc, 
 	      [AC_HELP_STRING([--enable-monodoc],[install monodoc documents default: yes])],
@@ -101,6 +91,7 @@
 	src/gnome-keyring-sharp-1.0.pc
 	src/Gnome.Keyring/Makefile
 	src/Gnome.Keyring/AssemblyInfo.cs
+	gnome-keyring-sharp-glue/Makefile
 	docs/Makefile
 	sample/Makefile
 ])

=== added directory 'gnome-keyring-sharp-glue'
=== added file 'gnome-keyring-sharp-glue/Makefile.am'
--- gnome-keyring-sharp-glue/Makefile.am	1970-01-01 00:00:00 +0000
+++ gnome-keyring-sharp-glue/Makefile.am	2010-03-30 04:29:24 +0000
@@ -0,0 +1,6 @@
+lib_LTLIBRARIES = libgnome-keyring-sharp-glue.la
+
+libgnome_keyring_sharp_glue_la_SOURCES = glue.c
+libgnome_keyring_sharp_glue_la_LDFLAGS = -module -avoid-version -no-undefined
+libgnome_keyring_sharp_glue_la_LIBADD = $(GNOME_KEYRING_LIBS)
+libgnome_keyring_sharp_glue_la_CFLAGS = $(GNOME_KEYRING_CFLAGS)

=== added file 'gnome-keyring-sharp-glue/glue.c'
--- gnome-keyring-sharp-glue/glue.c	1970-01-01 00:00:00 +0000
+++ gnome-keyring-sharp-glue/glue.c	2010-03-29 04:21:43 +0000
@@ -0,0 +1,36 @@
+#include <gnome-keyring.h>
+
+gpointer gks_attribute_list_new ()
+{
+	return gnome_keyring_attribute_list_new ();
+}
+
+gint32 gks_item_attribute_list_get_length (GnomeKeyringAttributeList *attrs)
+{
+	return (*attrs).len;
+}
+
+gboolean gks_item_attribute_list_index_is_string (GnomeKeyringAttributeList *attrs, gint32 index)
+{
+	return gnome_keyring_attribute_list_index (attrs, index).type == GNOME_KEYRING_ATTRIBUTE_TYPE_STRING;
+}
+
+gboolean gks_item_attribute_list_index_is_uint32 (GnomeKeyringAttributeList *attrs, gint32 index)
+{
+	return gnome_keyring_attribute_list_index (attrs, index).type == GNOME_KEYRING_ATTRIBUTE_TYPE_UINT32;
+}
+
+char * gks_item_attribute_list_get_index_string (GnomeKeyringAttributeList *attrs, gint32 index)
+{
+	return gnome_keyring_attribute_list_index (attrs, index).value.string;
+}
+
+guint32 gks_item_attribute_list_get_index_uint32 (GnomeKeyringAttributeList *attrs, gint32 index)
+{
+	return gnome_keyring_attribute_list_index (attrs, index).value.integer;
+}
+
+char * gks_item_attribute_list_get_index_key (GnomeKeyringAttributeList *attrs, gint32 index)
+{
+	return gnome_keyring_attribute_list_index (attrs, index).name;
+}

=== added file 'gnome-keyring-sharp-glue/gnome-keyring-sharp-glue.cproj'
--- gnome-keyring-sharp-glue/gnome-keyring-sharp-glue.cproj	1970-01-01 00:00:00 +0000
+++ gnome-keyring-sharp-glue/gnome-keyring-sharp-glue.cproj	2010-03-29 01:45:21 +0000
@@ -0,0 +1,1 @@
+<?xml version="1.0" encoding="utf-8"?><Project DefaultTargets="Build" ToolsVersion="3.5" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">  <PropertyGroup>    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>    <ProductVersion>9.0.21022</ProductVersion>    <SchemaVersion>2.0</SchemaVersion>    <ProjectGuid>{870C2CD7-985E-48CD-9D22-48AD243819C3}</ProjectGuid>    <Compiler>      <Compiler ctype="GccCompiler" xmlns="" />    </Compiler>    <Language>C</Language>    <Target>Bin</Target>  </PropertyGroup>  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">    <DebugSymbols>true</DebugSymbols>    <OutputPath>bin\Debug</OutputPath>    <Libs>      <Libs xmlns="">        <Lib>gnome-keyring</Lib>        <Lib>glib-2.0</Lib>      </Libs>    </Libs>    <DefineSymbols>DEBUG MONODEVELOP</DefineSymbols>    <SourceDirectory>.</SourceDirectory>    <OutputName>gnome-keyring-sharp-glue</OutputName>    <CompileTarget>SharedLibrary</CompileTarget>    <Includes>      <Includes xmlns="">        <Include>/usr/include/gnome-keyring-1</Include>        <Include>/usr/include/glib-2.0</Include>        <Include>/usr/lib/glib-2.0/include</Include>      </Includes>    </Includes>  </PropertyGroup>  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">    <OutputPath>bin\Release</OutputPath>    <DefineSymbols>MONODEVELOP</DefineSymbols>    <SourceDirectory>.</SourceDirectory>    <OptimizationLevel>3</OptimizationLevel>    <OutputName>gnome-keyring-sharp-glue</OutputName>    <CompileTarget>SharedLibrary</CompileTarget>  </PropertyGroup>  <ItemGroup>    <Compile Include="glue.c" />  </ItemGroup></Project>
\ No newline at end of file

=== added file 'gnome-keyring-sharp.csproj'
--- gnome-keyring-sharp.csproj	1970-01-01 00:00:00 +0000
+++ gnome-keyring-sharp.csproj	2010-03-29 02:30:34 +0000
@@ -0,0 +1,79 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{C9C7D12D-2534-4837-BD27-3B328CFC0C4F}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <RootNamespace>gnomekeyringsharp</RootNamespace>
+    <AssemblyName>gnome-keyring-sharp</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug</OutputPath>
+    <DefineConstants>DEBUG</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <DebugType>none</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Release</OutputPath>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <ItemGroup>
+    <Compile Include="src\Gnome.Keyring\AccessRights.cs" />
+    <Compile Include="src\Gnome.Keyring\AttributeType.cs" />
+    <Compile Include="src\Gnome.Keyring\GenericItemData.cs" />
+    <Compile Include="src\Gnome.Keyring\ItemACL.cs" />
+    <Compile Include="src\Gnome.Keyring\ItemData.cs" />
+    <Compile Include="src\Gnome.Keyring\ItemType.cs" />
+    <Compile Include="src\Gnome.Keyring\KeyringException.cs" />
+    <Compile Include="src\Gnome.Keyring\KeyringInfo.cs" />
+    <Compile Include="src\Gnome.Keyring\NetItemData.cs" />
+    <Compile Include="src\Gnome.Keyring\NoteItemData.cs" />
+    <Compile Include="src\Gnome.Keyring\Operation.cs" />
+    <Compile Include="src\Gnome.Keyring\RequestMessage.cs" />
+    <Compile Include="src\Gnome.Keyring\ResponseMessage.cs" />
+    <Compile Include="src\Gnome.Keyring\ResultCode.cs" />
+    <Compile Include="src\Gnome.Keyring\Ring.cs" />
+    <Compile Include="Tests\TestRing.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="src\Gnome.Keyring\AssemblyInfo.cs.in" />
+    <None Include="src\Gnome.Keyring\Makefile.am" />
+  </ItemGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="NDesk.DBus, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f6716e4f9b2ed099">
+      <Package>ndesk-dbus-1.0</Package>
+    </Reference>
+    <Reference Include="glib-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f">
+      <Package>glib-sharp-2.0</Package>
+    </Reference>
+    <Reference Include="nunit.framework">
+      <SpecificVersion>False</SpecificVersion>
+      <Package>mono-nunit</Package>
+    </Reference>
+    <Reference Include="Mono.Posix" />
+    <Reference Include="System.Core" />
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Tests\" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="gnome-keyring-sharp-glue\gnome-keyring-sharp-glue.cproj">
+      <Project>{870C2CD7-985E-48CD-9D22-48AD243819C3}</Project>
+      <Name>gnome-keyring-sharp-glue</Name>
+    </ProjectReference>
+  </ItemGroup>
+</Project>
\ No newline at end of file

=== added file 'gnome-keyring-sharp.sln'
--- gnome-keyring-sharp.sln	1970-01-01 00:00:00 +0000
+++ gnome-keyring-sharp.sln	2010-03-29 01:38:17 +0000
@@ -0,0 +1,29 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "gnome-keyring-sharp", "gnome-keyring-sharp.csproj", "{C9C7D12D-2534-4837-BD27-3B328CFC0C4F}"
+EndProject
+Project("{2857B73E-F847-4B02-9238-064979017E93}") = "gnome-keyring-sharp-glue", "gnome-keyring-sharp-glue\gnome-keyring-sharp-glue.cproj", "{870C2CD7-985E-48CD-9D22-48AD243819C3}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x86 = Debug|x86
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{870C2CD7-985E-48CD-9D22-48AD243819C3}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{870C2CD7-985E-48CD-9D22-48AD243819C3}.Debug|x86.Build.0 = Debug|Any CPU
+		{870C2CD7-985E-48CD-9D22-48AD243819C3}.Release|x86.ActiveCfg = Release|Any CPU
+		{870C2CD7-985E-48CD-9D22-48AD243819C3}.Release|x86.Build.0 = Release|Any CPU
+		{C9C7D12D-2534-4837-BD27-3B328CFC0C4F}.Debug|x86.ActiveCfg = Debug|x86
+		{C9C7D12D-2534-4837-BD27-3B328CFC0C4F}.Debug|x86.Build.0 = Debug|x86
+		{C9C7D12D-2534-4837-BD27-3B328CFC0C4F}.Release|x86.ActiveCfg = Release|x86
+		{C9C7D12D-2534-4837-BD27-3B328CFC0C4F}.Release|x86.Build.0 = Release|x86
+	EndGlobalSection
+	GlobalSection(MonoDevelopProperties) = preSolution
+		StartupItem = gnome-keyring-sharp.csproj
+		Policies = $0
+		$0.StandardHeader = $1
+		$1.inheritsSet = MITX11License
+	EndGlobalSection
+EndGlobal

=== added file 'src/Gnome.Keyring.dll.config'
--- src/Gnome.Keyring.dll.config	1970-01-01 00:00:00 +0000
+++ src/Gnome.Keyring.dll.config	2010-03-30 04:54:42 +0000
@@ -0,0 +1,3 @@
+<configuration>
+  <dllmap dll="libgnome-keyring.dll" target="libgnome-keyring.so.0"/>
+</configuration>

=== modified file 'src/Gnome.Keyring/Makefile.am'
--- src/Gnome.Keyring/Makefile.am	2006-08-08 03:35:09 +0000
+++ src/Gnome.Keyring/Makefile.am	2010-03-30 03:29:10 +0000
@@ -10,8 +10,5 @@
 		KeyringInfo.cs \
 		NetItemData.cs \
 		NoteItemData.cs \
-		Operation.cs \
-		RequestMessage.cs \
-		ResponseMessage.cs \
 		ResultCode.cs \
 		Ring.cs

=== removed file 'src/Gnome.Keyring/Operation.cs'
--- src/Gnome.Keyring/Operation.cs	2006-08-01 19:08:46 +0000
+++ src/Gnome.Keyring/Operation.cs	1970-01-01 00:00:00 +0000
@@ -1,54 +0,0 @@
-//
-// Gnome.Keyring.Operation.cs
-//
-// Authors:
-//	Gonzalo Paniagua Javier (gonzalo@ximian.com)
-//
-// (C) Copyright 2006 Novell, Inc. (http://www.novell.com)
-//
-
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-namespace Gnome.Keyring {
-	enum Operation {
-		LockAll,
-		SetDefaultKeyring,
-		GetDefaultKeyring,
-		ListKeyrings,
-		CreateKeyring,
-		LockKeyring,
-		UnlockKeyring,
-		DeleteKeyring,
-		GetKeyringInfo,
-		SetKeyringInfo,
-		ListItems,
-		Find,
-		CreateItem,
-		DeleteItem,
-		GetItemInfo,
-		SetItemInfo,
-		GetItemAttributes,
-		SetItemAttributes,
-		GetItemACL,
-		SetItemACL
-	}
-}
-

=== removed file 'src/Gnome.Keyring/RequestMessage.cs'
--- src/Gnome.Keyring/RequestMessage.cs	2006-08-07 15:38:59 +0000
+++ src/Gnome.Keyring/RequestMessage.cs	1970-01-01 00:00:00 +0000
@@ -1,173 +0,0 @@
-//
-// Gnome.Keyring.RequestMessage.cs
-//
-// Authors:
-//	Gonzalo Paniagua Javier (gonzalo@ximian.com)
-//
-// (C) Copyright 2006 Novell, Inc. (http://www.novell.com)
-//
-
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-using System.Collections;
-using System.IO;
-using System.Text;
-
-namespace Gnome.Keyring {
-	class RequestMessage {
-		MemoryStream stream = new MemoryStream ();
-		int op_start = -1;
-
-		public MemoryStream Stream {
-			get { return stream; }
-		}
-
-		public void CreateSimpleOperation (Operation op)
-		{
-			StartOperation (op);
-			EndOperation ();
-		}
-
-		public void CreateSimpleOperation (Operation op, string str1)
-		{
-			StartOperation (op);
-			Write (str1);
-			EndOperation ();
-		}
-
-		public void CreateSimpleOperation (Operation op, string str1, string str2)
-		{
-			StartOperation (op);
-			Write (str1);
-			Write (str2);
-			EndOperation ();
-		}
-
-		public void CreateSimpleOperation (Operation op, string str1, int i1)
-		{
-			StartOperation (op);
-			Write (str1);
-			Write (i1);
-			EndOperation ();
-		}
-
-		public void StartOperation (Operation op)
-		{
-			string appname = Ring.ApplicationName;
-			BinaryWriter writer = new BinaryWriter (stream);
-			writer.Write (0);
-
-			Write (appname);
-			int curpos = (int) stream.Position;
-			stream.Position = 0;
-			writer = new BinaryWriter (stream);
-			writer.Write (SwapBytes (curpos));
-			stream.Position = curpos;
-
-			op_start = (int) stream.Length;
-			writer.Write (0);
-			writer.Write (SwapBytes ((int) op));
-		}
-
-		public void EndOperation ()
-		{
-			int current = (int) stream.Length;
-			int size = SwapBytes (current - op_start);
-			stream.Position = op_start;
-			BinaryWriter writer = new BinaryWriter (stream);
-			writer.Write (size);
-		}
-
-		public void Write (string str)
-		{
-			WriteString (new BinaryWriter (stream), str);
-		}
-
-		static void WriteString (BinaryWriter writer, string str)
-		{
-			if (str == null) {
-				writer.Write ((int) -1);
-				return;
-			}
-			byte [] bytes = Encoding.UTF8.GetBytes (str);
-			writer.Write (SwapBytes (bytes.Length));
-			writer.Write (bytes);
-		}
-
-		public void Write (int i)
-		{
-			BinaryWriter writer = new BinaryWriter (stream);
-			writer.Write (SwapBytes (i));
-		}
-
-		public void WriteAttributes (Hashtable atts)
-		{
-			Hashtable copy = new Hashtable ();
-			foreach (string key in atts.Keys) {
-				object o = atts [key];
-				if (o != null)
-					copy [key] = o;
-				
-			}
-			BinaryWriter writer = new BinaryWriter (stream);
-			writer.Write (SwapBytes (copy.Count));
-			foreach (string key in copy.Keys) {
-				object o = atts [key];
-				if (o is string) {
-					EncodeAttribute (writer, key, (string) o);
-				} else if (o is int) {
-					int i = (int) o;
-					if (key == "port" && i == 0)
-						continue;
-					EncodeAttribute (writer, key, i);
-				} else {
-					throw new Exception ("Should not happen.");
-				}
-			}
-		}
-
-		static void EncodeAttribute (BinaryWriter writer, string name, string val)
-		{
-			WriteString (writer, name);
-			writer.Write (SwapBytes ((int) AttributeType.String));
-			WriteString (writer, val);
-		}
-
-		static void EncodeAttribute (BinaryWriter writer, string name, int val)
-		{
-			WriteString (writer, name);
-			writer.Write (SwapBytes ((int) AttributeType.UInt32));
-			writer.Write (SwapBytes (val));
-		}
-
-		static int SwapBytes (int i)
-		{
-			byte b0 = (byte) ((i >> 24) & 0xFF);
-			byte b1 = (byte) ((i >> 16) & 0xFF);
-			byte b2 = (byte) ((i >> 8) & 0xFF);
-			byte b3 = (byte) (i & 0xFF);
-			return b0 + (b1 << 8) + (b2 << 16) + (b3 << 24);
-		}
-
-	}
-}
-

=== removed file 'src/Gnome.Keyring/ResponseMessage.cs'
--- src/Gnome.Keyring/ResponseMessage.cs	2006-08-08 03:35:09 +0000
+++ src/Gnome.Keyring/ResponseMessage.cs	1970-01-01 00:00:00 +0000
@@ -1,108 +0,0 @@
-//
-// Gnome.Keyring.ResponseMessage.cs
-//
-// Authors:
-//	Gonzalo Paniagua Javier (gonzalo@ximian.com)
-//
-// (C) Copyright 2006 Novell, Inc. (http://www.novell.com)
-//
-
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-using System.Collections;
-using System.IO;
-using System.Text;
-
-using Mono.Unix.Native;
-
-namespace Gnome.Keyring {
-	class ResponseMessage {
-		byte [] buffer;
-		MemoryStream stream;
-
-		public ResponseMessage (byte [] buffer)
-		{
-			this.buffer = buffer;
-			stream = new MemoryStream (buffer);
-		}
-
-		public bool DataAvailable {
-			get { return (stream.Position < stream.Length); }
-		}
-
-		public string [] GetStringList ()
-		{
-			int nstrings = GetInt32 ();
-			string [] list = new string [nstrings];
-			for (int i = 0; i < nstrings; i++) {
-				list [i] = GetString ();
-			}
-
-			return list;
-		}
-
-		public string GetString ()
-		{
-			int len = GetInt32 ();
-			if (len == -1) {
-				return null;
-			}
-			int offset = (int) stream.Position;
-			string result =  Encoding.UTF8.GetString (buffer, offset, len);
-			stream.Position += len;
-			return result;
-		}
-
-		public int GetInt32 ()
-		{
-			byte b3 = (byte) stream.ReadByte ();
-			byte b2 = (byte) stream.ReadByte ();
-			byte b1 = (byte) stream.ReadByte ();
-			byte b0 = (byte) stream.ReadByte ();
-			return (b0 + (b1 << 8) + (b2 << 16) + (b3 << 24));
-		}
-
-		public DateTime GetDateTime ()
-		{
-			return NativeConvert.FromTimeT ((GetInt32 () << 32) + GetInt32 ());
-		}
-
-		public void ReadAttributes (Hashtable tbl)
-		{
-			int natts = GetInt32 ();
-			for (int i = 0; i < natts; i++) {
-				object val;
-				string name = GetString ();
-				AttributeType type = (AttributeType) GetInt32 ();
-				if (AttributeType.String == type) {
-					val = GetString ();
-				} else if (type == AttributeType.UInt32) {
-					val = GetInt32 ();
-				} else {
-					throw new Exception ("This should not happen: "  + type);
-				}
-				tbl [name] = val;
-			}
-		}
-	}
-}
-

=== modified file 'src/Gnome.Keyring/Ring.cs'
--- src/Gnome.Keyring/Ring.cs	2008-10-14 10:40:30 +0000
+++ src/Gnome.Keyring/Ring.cs	2010-03-30 03:41:31 +0000
@@ -31,16 +31,16 @@
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using System.IO;
 using System.Net;
 using System.Net.Sockets;
 using System.Reflection;
+using System.Runtime.InteropServices;
 
 using Mono.Unix;
 
-#if WITH_DBUS
-using NDesk.DBus;
-#endif
+using GLib;
 
 namespace Gnome.Keyring {
 	public class Ring {
@@ -70,396 +70,579 @@
 			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern bool gnome_keyring_is_available ();
+		
 		public static bool Available {
 			get {
-				Socket sock = Connect ();
-				if (sock != null) {
-					sock.Close ();
-					return true;
-				}
-				return false;
-			}
-		}
-
-		static Socket Connect ()
-		{
-			string filename;
-			Socket sock;
-		 
-			filename = Environment.GetEnvironmentVariable ("GNOME_KEYRING_SOCKET");
-			sock = Connect (filename);
-
-#if WITH_DBUS
-			if (sock == null) {
-				try {
-					filename = Bus.Session.GetObject<IDaemon> ("org.gnome.keyring", new ObjectPath ("/org/gnome/keyring/daemon")).GetSocketPath ();
-				} catch (Exception) {
-					filename = null;
-				}
-				sock = Connect (filename);
-			}
-#endif
-
-			return sock;
-		}
-
-		static Socket Connect (string filename)
-		{
-			if (filename == null || filename == "")
-				return null;
-
-			EndPoint ep = new UnixEndPoint (filename);
-			Socket sock = new Socket (AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
-			try {
-				sock.Connect (ep);
-			} catch (Exception) {
-				sock.Close ();
-				return null;
-			}
-			return sock;
-		}
-
-		static int GetInt32 (Socket sock)
-		{
-			byte [] cuatro = new byte [4];
-			if (sock.Receive (cuatro) != 4)
-				throw new KeyringException (ResultCode.IOError);
-			return (cuatro [3] + (cuatro [2] << 8) + (cuatro [1] << 16) + (cuatro [0] << 24));
-		}
-
-		static byte [] one = new byte [1];
-		static ResponseMessage SendRequest (MemoryStream stream)
-		{
-			Socket sock = Connect ();
-			if (sock == null)
-				throw new KeyringException (ResultCode.NoKeyringDaemon);
-
-			try {
-				sock.Send (one); // Credentials byte
-				byte [] buffer = stream.ToArray ();
-				sock.Send (buffer);
-				int packet_size = GetInt32 (sock) - 4;
-				if (packet_size < 0)
-					throw new KeyringException (ResultCode.IOError);
-				byte [] response = new byte [packet_size];
-				int nbytes = sock.Receive (response);
-				if (nbytes != response.Length)
-					throw new KeyringException (ResultCode.IOError);
-				ResponseMessage resp = new ResponseMessage (response);
-				ResultCode result = (ResultCode) resp.GetInt32 ();
-				if (result != 0)
-					throw new KeyringException (result);
-
-				return resp;
-			} finally {
-				sock.Close ();
-			}
-		}
-
+				return gnome_keyring_is_available ();
+			}
+		}
+
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_lock_all_sync ();
+		
 		public static void LockAll ()
 		{
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.LockAll);
-			SendRequest (req.Stream);
+			ResultCode result = gnome_keyring_lock_all_sync ();
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_set_default_keyring_sync (string keyring);
+		
 		public static void SetDefaultKeyring (string newKeyring)
 		{
 			if (newKeyring == null)
 				throw new ArgumentNullException ("newKeyring");
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.SetDefaultKeyring, newKeyring);
-			SendRequest (req.Stream);
+			ResultCode result = gnome_keyring_set_default_keyring_sync (newKeyring);
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_get_default_keyring_sync (out IntPtr keyring);
+		
 		public static string GetDefaultKeyring ()
 		{
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.GetDefaultKeyring);
-			ResponseMessage resp = SendRequest (req.Stream);
-			return resp.GetString ();
+			IntPtr keyring_name;
+			ResultCode result = gnome_keyring_get_default_keyring_sync (out keyring_name);
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			return GLib.Marshaller.PtrToStringGFree (keyring_name);
 		}
 
-		public static string [] GetKeyrings ()
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_list_keyring_names_sync (out IntPtr keyringList);
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_string_list_free (IntPtr stringList);
+		
+		public static string[] GetKeyrings ()
 		{
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.ListKeyrings);
-			ResponseMessage resp = SendRequest (req.Stream);
-			return resp.GetStringList ();
+			IntPtr keyring_list;
+			ResultCode result = gnome_keyring_list_keyring_names_sync (out keyring_list);
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			var retval = (string[])GLib.Marshaller.ListPtrToArray (keyring_list, typeof(GLib.List), false, false, typeof(string));
+			gnome_keyring_string_list_free (keyring_list);
+			return retval;
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_create_sync (string keyringName, string password);
+		
 		public static void CreateKeyring (string name, string password)
 		{
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.CreateKeyring, name, password);
-			SendRequest (req.Stream);
+			ResultCode result = gnome_keyring_create_sync (name, password);
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
-
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_lock_sync (string keyring);
+		
 		public static void Lock (string keyring)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.LockKeyring, keyring);
-			SendRequest (req.Stream);
+			ResultCode result = gnome_keyring_lock_sync (keyring);
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_unlock_sync (string keyring, string password);
 
 		public static void Unlock (string keyring, string password)
 		{
-			if (keyring == null)
-				throw new ArgumentNullException ("keyring");
-
-			if (password == null)
-				throw new ArgumentNullException ("password");
-
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.UnlockKeyring, keyring, password);
-			try {
-				SendRequest (req.Stream);
-			} catch (KeyringException ke) {
-				if (ke.ResultCode != ResultCode.AlreadyUnlocked)
-					throw;
+			ResultCode result = gnome_keyring_unlock_sync (keyring, password);
+			
+			if (!(result == ResultCode.Ok || result == ResultCode.AlreadyUnlocked)) {
+				throw new KeyringException (result);
 			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_delete_sync (string keyring);
+		
 		public static void DeleteKeyring (string keyring)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.DeleteKeyring, keyring);
-			SendRequest (req.Stream);
+			ResultCode result = gnome_keyring_delete_sync (keyring);
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
-		public static int [] ListItemIDs (string keyring)
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_list_item_ids_sync (string keyring, out IntPtr ids);
+		
+		public static int[] ListItemIDs (string keyring)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.ListItems, keyring);
-			ResponseMessage resp = SendRequest (req.Stream);
-			int len = resp.GetInt32 ();
-			int [] result = new int [len];
-			for (int i = 0; i < len; i++) {
-				result [i] = resp.GetInt32 ();
-			}
-
-			return result;
-		}
-
+			IntPtr idlist;
+			ResultCode result = gnome_keyring_list_item_ids_sync (keyring, out idlist);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			IntPtr[] ptrArray = (IntPtr[])GLib.Marshaller.ListPtrToArray (idlist, typeof(GLib.List), true, false, typeof(IntPtr));
+			int[] ids = new int[ptrArray.Length];
+			for (int i = 0; i < ptrArray.Length; i++) {
+				ids[i] = ptrArray[i].ToInt32 ();
+			}
+			
+			return ids;
+		}
+
+		
+		static void NativeListFromAttributes (IntPtr attrList, Hashtable attributes)
+		{
+			foreach (string key in attributes.Keys) {
+				if (attributes[key] is string) {
+					gnome_keyring_attribute_list_append_string (attrList, key, (string)attributes[key]);
+				} else if (attributes[key] is int) {
+					gnome_keyring_attribute_list_append_uint32 (attrList, key, (uint)((int)attributes[key]));
+				} else {
+					throw new ArgumentException (String.Format ("Attribute \"{0}\" has invalid parameter type: {1}", key, attributes[key].GetType ()));
+				}
+			}
+		}
+		
+		static void AttributesFromNativeList (IntPtr attrList, Hashtable attributes)
+		{
+			int listLength = gks_item_attribute_list_get_length (attrList);
+			for (int i = 0; i < listLength; i++) {
+				string key = Marshal.PtrToStringAnsi (gks_item_attribute_list_get_index_key (attrList, i));
+				if (gks_item_attribute_list_index_is_string (attrList, i)) {
+					attributes[key] = Marshal.PtrToStringAnsi (gks_item_attribute_list_get_index_string (attrList, i));
+				} else if (gks_item_attribute_list_index_is_uint32 (attrList, i)) {
+					attributes[key] = (int)gks_item_attribute_list_get_index_uint32 (attrList, i);
+				}
+			}
+		}
+		
+		[StructLayout(LayoutKind.Sequential)]
+		struct GnomeKeyringFound
+		{
+			public IntPtr keyring;
+			public UInt32 item_id;
+			public IntPtr attrList;
+			public IntPtr secret;
+		}
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_find_items_sync (ItemType type, IntPtr attrList, out IntPtr foundList);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_found_list_free (IntPtr foundList);
+		
 		static ItemData [] empty_item_data = new ItemData [0];
-		public static ItemData [] Find (ItemType type, Hashtable atts)
+		public static ItemData[] Find (ItemType type, Hashtable atts)
 		{
 			if (atts == null)
 				throw new ArgumentNullException ("atts");
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.Find);
-			req.Write ((int) type);
-			req.WriteAttributes (atts);
-			req.EndOperation ();
-
-			ResponseMessage resp = null;
-			try {
-				resp = SendRequest (req.Stream);
-			} catch (KeyringException ke) {
-				if (ke.ResultCode == ResultCode.Denied ||
-				    ke.ResultCode == ResultCode.NoMatch)
-					return empty_item_data;
-				throw;
+			
+			IntPtr passwordList;
+			IntPtr attrList = gks_attribute_list_new ();
+			
+			NativeListFromAttributes (attrList, atts);
+			
+			ResultCode result = gnome_keyring_find_items_sync (type, attrList, out passwordList);
+			
+			if (result == ResultCode.Denied || result == ResultCode.NoMatch) {
+				return empty_item_data;
+			}
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			IntPtr[] passwordStructs = (IntPtr[])GLib.Marshaller.ListPtrToArray (passwordList, typeof(GLib.List), false, false, typeof(IntPtr));
+			List<GnomeKeyringFound> passwords = new List<GnomeKeyringFound> ();
+			
+			foreach (IntPtr ptr in passwordStructs) {
+				passwords.Add ((GnomeKeyringFound)Marshal.PtrToStructure (ptr, typeof(GnomeKeyringFound)));
 			}
 
 			ArrayList list = new ArrayList ();
-			while (resp.DataAvailable) {
+			foreach (var password in passwords) {
 				ItemData found = ItemData.GetInstanceFromItemType (type);
-				found.Keyring = resp.GetString ();
-				found.ItemID = resp.GetInt32 ();
-				found.Secret = resp.GetString ();
+				found.ItemID = (int)password.item_id;
+				found.Secret = Marshal.PtrToStringAnsi (password.secret);
+				found.Keyring = Marshal.PtrToStringAnsi (password.keyring);
 				found.Attributes = new Hashtable ();
-				resp.ReadAttributes (found.Attributes);
+				AttributesFromNativeList (password.attrList, found.Attributes);
 				found.SetValuesFromAttributes ();
 				list.Add (found);
 			}
 
+			gnome_keyring_found_list_free (passwordList);
+			gnome_keyring_attribute_list_free (attrList);
+			
 			return (ItemData []) list.ToArray (typeof (ItemData));
 		}
 
+		[StructLayout (LayoutKind.Sequential)]
+		struct GnomeKeyringNetworkPasswordData
+		{
+			public IntPtr keyring;
+			public UInt32 item_id;
+			
+			public IntPtr protocol;
+			public IntPtr server;
+			public IntPtr @object;
+			public IntPtr authtype;
+			public UInt32 port;
+			
+			public IntPtr user;
+			public IntPtr domain;
+			public IntPtr password;
+		}
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_find_network_password_sync (string user, string domain, string server,
+			string @object, string protocol, string authtype, UInt32 port, out IntPtr passwordList);
+		
 		static NetItemData [] empty_net_item_data = new NetItemData [0];
-		public static NetItemData [] FindNetworkPassword (string user, string domain, string server, string obj,
+		public static NetItemData[] FindNetworkPassword (string user, string domain, string server, string obj,
 									string protocol, string authtype, int port)
 		{
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.Find);
-			req.Write ((int) ItemType.NetworkPassword);
-			Hashtable tbl = new Hashtable ();
-			tbl ["user"] = user;
-			tbl ["domain"] = domain;
-			tbl ["server"] = server;
-			tbl ["object"] = obj;
-			tbl ["protocol"] = protocol;
-			tbl ["authtype"] = authtype;
-			if (port != 0)
-				tbl ["port"] = port;
-			req.WriteAttributes (tbl);
-			req.EndOperation ();
-
-			ResponseMessage resp = null;
-			try {
-				resp = SendRequest (req.Stream);
-			} catch (KeyringException ke) {
-				if (ke.ResultCode == ResultCode.Denied ||
-				    ke.ResultCode == ResultCode.NoMatch)
-					return empty_net_item_data;
-				throw;
-			}
+			IntPtr passwordList;
+			
+			ResultCode result = gnome_keyring_find_network_password_sync (user, domain, server, obj, protocol, authtype, (uint)port, out passwordList);
+			
+			if (result == ResultCode.Denied || result == ResultCode.NoMatch) {
+				return empty_net_item_data;
+			}
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			IntPtr[] passwordStructs = (IntPtr[])GLib.Marshaller.ListPtrToArray (passwordList, typeof(GLib.List), false, false, typeof(IntPtr));
+			List<GnomeKeyringNetworkPasswordData> passwords = new List<GnomeKeyringNetworkPasswordData> ();
+			
+			foreach (IntPtr ptr in passwordStructs) {
+				passwords.Add ((GnomeKeyringNetworkPasswordData)Marshal.PtrToStructure (ptr, typeof(GnomeKeyringNetworkPasswordData)));
+			}
+			
 			ArrayList list = new ArrayList ();
-			while (resp.DataAvailable) {
+			foreach (var password in passwords) {
 				NetItemData found = new NetItemData ();
-				found.Keyring = resp.GetString ();
-				found.ItemID = resp.GetInt32 ();
-				found.Secret = resp.GetString ();
+				found.Keyring = Marshal.PtrToStringAnsi (password.keyring);
+				found.ItemID = (int)password.item_id;
+				found.Secret = Marshal.PtrToStringAnsi (password.password);
 				found.Attributes = new Hashtable ();
-				resp.ReadAttributes (found.Attributes);
+				
+				SetAttributeIfNonNull (found.Attributes, "protocol", password.protocol);
+				SetAttributeIfNonNull (found.Attributes, "server", password.server);
+				SetAttributeIfNonNull (found.Attributes, "object", password.@object);
+				SetAttributeIfNonNull (found.Attributes, "authtype", password.authtype);
+				SetAttributeIfNonNull (found.Attributes, "user", password.user);
+				SetAttributeIfNonNull (found.Attributes, "domain", password.domain);
+
+				if (password.port != 0) {
+					found.Attributes["port"] = (int)password.port;
+				}
+				
 				found.SetValuesFromAttributes ();
 				list.Add (found);
 			}
 
 			return (NetItemData []) list.ToArray (typeof (NetItemData));
 		}
+		
+		static void SetAttributeIfNonNull (Hashtable attrs, string key, IntPtr maybeString)
+		{
+			if (maybeString != IntPtr.Zero) {
+				attrs[key] = Marshal.PtrToStringAnsi (maybeString);
+			}
+		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_item_create_sync (string keyring, 
+			ItemType type, 
+			string displayName, 
+			IntPtr attributes,
+			IntPtr secret,
+			bool updateIfExists,
+			out UInt32 itemId);
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_memory_strdup (string str);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_memory_free (IntPtr str);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_attribute_list_append_string (IntPtr attributes, string name, string val);
+		[DllImport("libgnome-keyring.dll")]
+		static extern void gnome_keyring_attribute_list_append_uint32 (IntPtr attributes, string name, UInt32 val);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_attribute_list_free (IntPtr attributes);
+		[DllImport ("gnome-keyring-sharp-glue.dll")]
+		static extern IntPtr gks_attribute_list_new ();
+		
 		public static int CreateItem (string keyring, ItemType type, string displayName, Hashtable attributes,
 						string secret, bool updateIfExists)
 		{
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.CreateItem);
-			req.Write (keyring);
-			req.Write (displayName);
-			req.Write (secret);
-			req.WriteAttributes (attributes);
-			req.Write ((int) type);
-			req.Write (updateIfExists ? 1 : 0);
-			req.EndOperation ();
-			ResponseMessage resp = SendRequest (req.Stream);
-			return resp.GetInt32 ();
+			uint id;
+			IntPtr secure_secret = gnome_keyring_memory_strdup (secret);
+			IntPtr attrs = gks_attribute_list_new ();
+			
+			NativeListFromAttributes (attrs, attributes);
+			
+			ResultCode result = gnome_keyring_item_create_sync (keyring, type, displayName, attrs, secure_secret, updateIfExists, out id);
+			
+			gnome_keyring_attribute_list_free (attrs);
+			gnome_keyring_memory_free (secure_secret);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			return (int)id;
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_item_delete_sync (string keyring, UInt32 id);
+		
 		public static void DeleteItem (string keyring, int id)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.DeleteItem, keyring, id);
-			SendRequest (req.Stream);
+			ResultCode result = gnome_keyring_item_delete_sync (keyring, (uint)id);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_set_network_password_sync (string keyring,
+			string user,
+			string domain,
+			string server,
+			string @object,
+			string protocol,
+			string authType,
+			UInt32 port,
+			string password,
+			out UInt32 id);
+		
 		public static int CreateOrModifyNetworkPassword (string keyring, string user, string domain, string server, string obj,
 								string protocol, string authtype, int port, string password)
 		{
-			Hashtable tbl = new Hashtable ();
-			tbl ["user"] = user;
-			tbl ["domain"] = domain;
-			tbl ["server"] = server;
-			tbl ["object"] = obj;
-			tbl ["protocol"] = protocol;
-			tbl ["authtype"] = authtype;
-			if (port != 0)
-				tbl ["port"] = port;
-
-			string display_name;
-			if (port != 0)
-				display_name = String.Format ("{0}@{1}:{3}/{2}", user, server, obj, port);
-			else
-				display_name = String.Format ("{0}@{1}/{2}", user, server, obj);
-
-			return CreateItem (keyring, ItemType.NetworkPassword, display_name, tbl, password, true);
+			uint id;
+			ResultCode result = gnome_keyring_set_network_password_sync (keyring, user, domain, server, obj, protocol, authtype, (uint)port, password, out id);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			return (int)id;
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_item_get_info_sync (string keyring, UInt32 id, out IntPtr itemInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ItemType gnome_keyring_item_info_get_type (IntPtr itemInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_item_info_get_ctime (IntPtr itemInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_item_info_get_mtime (IntPtr itemInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_item_info_get_display_name (IntPtr itemInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_item_info_get_secret (IntPtr itemInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern void gnome_keyring_item_info_free (IntPtr itemInfo);
+		
 		public static ItemData GetItemInfo (string keyring, int id)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.GetItemInfo, keyring, id);
-			ResponseMessage resp = SendRequest (req.Stream);
-			ItemType itype = (ItemType) resp.GetInt32 ();
-			ItemData item = ItemData.GetInstanceFromItemType (itype);
-			string name = resp.GetString ();
-			string secret = resp.GetString ();
-			DateTime mtime = resp.GetDateTime ();
-			DateTime ctime =  resp.GetDateTime ();
+			IntPtr itemInfo;
+			
+			ResultCode result = gnome_keyring_item_get_info_sync (keyring, (uint)id, out itemInfo);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			ItemData item = ItemData.GetInstanceFromItemType (gnome_keyring_item_info_get_type (itemInfo));
+			item.Attributes = new Hashtable ();
+			item.Attributes["keyring_ctime"] = GLib.Marshaller.time_tToDateTime (gnome_keyring_item_info_get_ctime (itemInfo));
+			item.Attributes["keyring_mtime"] = GLib.Marshaller.time_tToDateTime (gnome_keyring_item_info_get_mtime (itemInfo));
+			item.Attributes["name"] = Marshal.PtrToStringAnsi (gnome_keyring_item_info_get_display_name (itemInfo));
+			
 			item.Keyring = keyring;
 			item.ItemID = id;
-			item.Secret = secret;
-			Hashtable tbl = new Hashtable ();
-			tbl ["name"] = name;
-			tbl ["keyring_ctime"] = ctime;
-			tbl ["keyring_mtime"] = mtime;
-			item.Attributes = tbl;
+			item.Secret = Marshal.PtrToStringAnsi (gnome_keyring_item_info_get_secret (itemInfo));
+
 			item.SetValuesFromAttributes ();
+			
+			gnome_keyring_item_info_free (itemInfo);
+			
 			return item;
 		}
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_item_set_info_sync (string keyring, UInt32 id, IntPtr itemInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_item_info_new ();
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_item_info_set_display_name (IntPtr itemInfo, string displayName);
+		[DllImport("libgnome-keyring.dll")]
+		static extern void gnome_keyring_item_info_set_type (IntPtr itemInfo, ItemType type);
+		[DllImport("libgnome-keyring.dll")]
+		static extern void gnome_keyring_item_info_set_secret (IntPtr itemInfo, string secret);
 
 		public static void SetItemInfo (string keyring, int id, ItemType type, string displayName, string secret)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.SetItemInfo);
-			req.Write (keyring);
-			req.Write (id);
-			req.Write ((int) type);
-			req.Write (displayName);
-			req.Write (secret);
-			req.EndOperation ();
-			SendRequest (req.Stream);
+			IntPtr itemInfo = gnome_keyring_item_info_new ();
+			gnome_keyring_item_info_set_display_name (itemInfo, displayName);
+			gnome_keyring_item_info_set_type (itemInfo, type);
+			gnome_keyring_item_info_set_secret (itemInfo, secret);
+			
+			ResultCode result = gnome_keyring_item_set_info_sync (keyring, (uint)id, itemInfo);
+			
+			gnome_keyring_item_info_free (itemInfo);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_item_get_attributes_sync (string keyring, UInt32 id, out IntPtr attributes);
+		[DllImport ("gnome-keyring-sharp-glue.dll")]
+		static extern int gks_item_attribute_list_get_length (IntPtr attrList);
+		[DllImport ("gnome-keyring-sharp-glue.dll")]
+		static extern bool gks_item_attribute_list_index_is_string (IntPtr attrList, int index);
+		[DllImport("gnome-keyring-sharp-glue.dll")]
+		static extern bool gks_item_attribute_list_index_is_uint32 (IntPtr attrList, int index);
+		[DllImport ("gnome-keyring-sharp-glue.dll")]
+		static extern IntPtr gks_item_attribute_list_get_index_string (IntPtr attrList, int index);
+		[DllImport ("gnome-keyring-sharp-glue.dll")]
+		static extern UInt32 gks_item_attribute_list_get_index_uint32 (IntPtr attrList, int index);
+		[DllImport ("gnome-keyring-sharp-glue.dll")]
+		static extern IntPtr gks_item_attribute_list_get_index_key (IntPtr attrList, int index);
+		
 		public static Hashtable GetItemAttributes (string keyring, int id)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.GetItemAttributes, keyring, id);
-			ResponseMessage resp = SendRequest (req.Stream);
-			Hashtable tbl = new Hashtable ();
-			resp.ReadAttributes (tbl);
-			return tbl;
+			IntPtr attributes;
+			Hashtable retVal = new Hashtable ();
+			
+			ResultCode result = gnome_keyring_item_get_attributes_sync (keyring, (uint)id, out attributes);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			AttributesFromNativeList (attributes, retVal);
+			
+			gnome_keyring_attribute_list_free (attributes);
+			
+			return retVal;
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_item_set_attributes_sync (string keyring, UInt32 id, IntPtr attrList);
+		
 		public static void SetItemAttributes (string keyring, int id, Hashtable atts)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.SetItemAttributes);
-			req.Write (keyring);
-			req.Write (id);
-			req.WriteAttributes (atts);
-			req.EndOperation ();
-			SendRequest (req.Stream);
+			IntPtr attrList = gks_attribute_list_new ();
+			foreach (string key in atts.Keys) {
+				if (atts[key] is string) {
+					gnome_keyring_attribute_list_append_string (attrList, key, (string)atts[key]);
+				} else if (atts[key] is int) {
+					gnome_keyring_attribute_list_append_uint32 (attrList, key, (uint)((int)atts[key]));
+				} else {
+					throw new ArgumentException (String.Format ("Attribute \"{0}\" has invalid parameter type: {1}", key, atts[key].GetType ()));
+				}
+			}
+			
+			ResultCode result = gnome_keyring_item_set_attributes_sync (keyring, (uint)id, attrList);
+			
+			gnome_keyring_attribute_list_free (attrList);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_get_info_sync (string keyringName, out IntPtr keyringInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_info_free (IntPtr keyringInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_info_get_ctime (IntPtr keyringInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern IntPtr gnome_keyring_info_get_mtime (IntPtr keyringInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern int gnome_keyring_info_get_lock_timeout (IntPtr keyringInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern bool gnome_keyring_info_get_is_locked (IntPtr keyringInfo);
+		[DllImport("libgnome-keyring.dll")]
+		static extern bool gnome_keyring_info_get_lock_on_idle (IntPtr keyringInfo);
+		
 		public static KeyringInfo GetKeyringInfo (string keyring)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.GetKeyringInfo, keyring);
-			ResponseMessage resp = SendRequest (req.Stream);
-			return new KeyringInfo (keyring, (resp.GetInt32 () != 0),
-							resp.GetInt32 (),
-							resp.GetDateTime (),
-							resp.GetDateTime (),
-							(resp.GetInt32 () != 0));
+			IntPtr keyring_info = IntPtr.Zero;
+			ResultCode result = gnome_keyring_get_info_sync (keyring, out keyring_info);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			DateTime ctime = GLib.Marshaller.time_tToDateTime (gnome_keyring_info_get_ctime (keyring_info));
+			DateTime mtime = GLib.Marshaller.time_tToDateTime (gnome_keyring_info_get_mtime (keyring_info));
+			KeyringInfo retval = new KeyringInfo (keyring,
+				gnome_keyring_info_get_lock_on_idle (keyring_info),
+				gnome_keyring_info_get_lock_timeout (keyring_info),
+				mtime,
+				ctime,
+				gnome_keyring_info_get_is_locked (keyring_info)
+				);
+			
+			
+			gnome_keyring_info_free (keyring_info);
+			return retval;
 		}
+		
+		[DllImport ("libgnome-keyring.dll")]
+		static extern ResultCode gnome_keyring_set_info_sync (string keyring, IntPtr keyringInfo);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_info_set_lock_timeout (IntPtr keyringInfo, UInt32 timeout);
+		[DllImport ("libgnome-keyring.dll")]
+		static extern void gnome_keyring_info_set_lock_on_idle (IntPtr keyringInfo, bool lockOnIdle);
 
 		public static void SetKeyringInfo (string keyring, KeyringInfo info)
 		{
@@ -469,41 +652,47 @@
 			if (info == null)
 				throw new ArgumentNullException ("info");
 
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.SetKeyringInfo);
-			req.Write (keyring);
-			req.Write (info.LockOnIdle ? 1 : 0);
-			req.Write (info.LockTimeoutSeconds);
-			req.EndOperation ();
-			SendRequest (req.Stream);
+		
+			IntPtr keyring_info;
+			ResultCode result = gnome_keyring_get_info_sync (keyring, out keyring_info);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
+			
+			gnome_keyring_info_set_lock_timeout (keyring_info, (uint)info.LockTimeoutSeconds);
+			gnome_keyring_info_set_lock_on_idle (keyring_info, info.LockOnIdle);
+			
+			result = gnome_keyring_set_info_sync (keyring, keyring_info);
+
+			gnome_keyring_info_free (keyring_info);
+			
+			if (result != ResultCode.Ok) {
+				throw new KeyringException (result);
+			}
 		}
 
+		[Obsolete ("Item ACLs are deprecated.  GetItemACL never returns any ACLs")]
 		public static ArrayList GetItemACL (string keyring, int id)
 		{
 			if (keyring == null)
 				throw new ArgumentNullException ("keyring");
 
-			RequestMessage req = new RequestMessage ();
-			req.CreateSimpleOperation (Operation.GetItemACL, keyring, id);
-			ResponseMessage resp = SendRequest (req.Stream);
-			int count = resp.GetInt32 ();
-			ArrayList list = new ArrayList (count);
-			for (int i = 0; i < count; i++) {
-				list.Add (new ItemACL (resp.GetString (), resp.GetString (), (AccessRights) resp.GetInt32 ()));
-			}
-			return list;
+			return new ArrayList ();
 		}
 
+		[Obsolete("Item ACLs are deprecated.  SetItemACL has no effect.")]
 		public static void SetItemACL (string keyring, int id, ICollection acls)
 		{
 			if (acls == null)
 				throw new ArgumentNullException ("acls");
 
-			ItemACL [] arr = new ItemACL [acls.Count];
+			ItemACL[] arr = new ItemACL[acls.Count];
 			acls.CopyTo (arr, 0);
 			SetItemACL (keyring, id, arr);
 		}
-
+		
+		[Obsolete("Item ACLs are deprecated.  SetItemACL has no effect.")]
 		public static void SetItemACL (string keyring, int id, ItemACL [] acls)
 		{
 			if (keyring == null)
@@ -514,28 +703,6 @@
 
 			if (acls.Length == 0)
 				throw new ArgumentException ("Empty ACL set.", "acls");
-
-			RequestMessage req = new RequestMessage ();
-			req.StartOperation (Operation.SetItemACL);
-			req.Write (keyring);
-			req.Write (id);
-			req.Write (acls.Length);
-			foreach (ItemACL acl in acls) {
-				req.Write (acl.DisplayName);
-				req.Write (acl.FullPath);
-				req.Write ((int) acl.Access);
-			}
-			req.EndOperation ();
-			SendRequest (req.Stream);
 		}
 	}
-
-#if WITH_DBUS
-	[Interface ("org.gnome.keyring.Daemon")]
-	interface IDaemon
-	{
-		string GetSocketPath ();
-	}
-#endif
 }
-

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2007-10-16 22:46:31 +0000
+++ src/Makefile.am	2010-03-30 05:11:26 +0000
@@ -5,13 +5,13 @@
 SNK=$(ASSEMBLY_NAME).snk
 
 pkgconfigdir=$(libdir)/pkgconfig
-CSFLAGS+= -debug+ -debug:full -nologo -r:Mono.Posix.dll
+CSFLAGS += -debug+ -debug:full -nologo -r:Mono.Posix.dll
 
 pkgconfig_DATA = gnome-keyring-sharp-1.0.pc
 
-CLEANFILES = $(ASSEMBLY_NAME).*
+CLEANFILES = $(ASSEMBLY_NAME).dll $(ASSEMBLY_NAME).dll.mdb $(ASSEMBLY_NAME).snk
 
-gnomekeyring_references = $(DBUS_LIBS)
+gnomekeyring_references = $(GLIB_SHARP_LIBS)
 
 gnomekeyring_sources  = \
 			Gnome.Keyring/AccessRights.cs \
@@ -24,9 +24,6 @@
 			Gnome.Keyring/KeyringInfo.cs \
 			Gnome.Keyring/NetItemData.cs \
 			Gnome.Keyring/NoteItemData.cs \
-			Gnome.Keyring/Operation.cs \
-			Gnome.Keyring/RequestMessage.cs \
-			Gnome.Keyring/ResponseMessage.cs \
 			Gnome.Keyring/ResultCode.cs \
 			Gnome.Keyring/Ring.cs
 
@@ -50,3 +47,4 @@
 	echo "$(GACUTIL) /u $(ASSEMBLY_NAME) $(GACUTIL_FLAGS)"; \
 	$(GACUTIL) /u $(ASSEMBLY_NAME) /package $(PACKAGE)-$(API_VERSION) $(GACUTIL_FLAGS) || exit 1;
 
+EXTRA_DIST=Gnome.Keyring.dll.config

